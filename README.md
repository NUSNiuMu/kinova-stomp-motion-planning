# 新加坡国立大学 EE5112 项目 2 AY 25/26

## 1 使用 STOMP 的机器人机械臂避障路径规划

### 注意:

*   这个项目占 **30% 的课程评估 (CA)**。报告和代码占 20% 的 CA。演示占另外 10% 的 CA。评估将基于：
    *   代码的正确性、质量、效率、实际考虑以及额外的新功能/新颖实现，
    *   设计和规划结果的挑战性和新颖性，
    *   演示的清晰度、有效性和视觉效果等，
    *   您对定理/算法的理解。
*   请在您的报告和演示中突出以上任何一点。
*   不要做虚假声明。要诚实。
*   这是一个小组项目，但所有成员都应贡献并展示个人作品。个人在演示中的表现将单独评估。
*   将提供一个不完整的示例代码，供您的小组在其上构建。

### 任务:

1.  完成提供给您的示例代码，以便在完成后，能够运行 MATLAB 实时脚本 `KINOVA_STOMP_Path_Planning.mlx` 以成功规划无碰撞路径并显示动画（在原始碰撞避免设置下）。以下代码文件不完整：`helperSTOMP.m`、`updateJointsWorldPosition.m`、`stompDTheta.m`、`stompSamples.m`、`stompObstacleCost.m`。

2.  选择一个不同的机器人机械臂，并在与任务 1 类似的场景中为其规划路径。在 MATLAB 函数 `loadrobot()` 的帮助页面上，您可以找到与 Matlab 一起提供的机器人机械臂列表。

    您还可以加载外部机器人。这是 Movelt 支持的机器人机械臂列表：[https://moveit.ros.org/robots/](https://moveit.ros.org/robots/)。Matlab 函数 `importrobot()` 允许您通过其 URDF 导入外部机器人。但是您还需要在 Matlab 的可视化命令中指定网格文件（需要一些研究）。在这里，您可以找到 Kuka KR210 的 xacro 和网格文件，它有一个棱柱关节。您可以使用 ROS 命令将 xacro 文件转换为 URDF：

    ```
    rosrun xacro xacro model.xacro > model.urdf
    ```

    为其余任务使用您选择的机器人机械臂。

3.  使用基于扭转理论的指数积 (PoE) 公式的程序替换 MATLAB 内置的正向运动学 (`getTransform`)。您可以使用教科书提供的代码（可在 [Github](https://github.com/) 上获得，其中函数 `FKinSpace.m` 计算给定空间扭转和固定框架中的末端执行器姿态的正向运动学。请注意，它依赖于该库中的其他函数）。教科书可以在此页面中找到。但是，您在代码中的实现/集成需要考虑必要的代码效率。您需要根据其几何参数确定所选机器ンの每个轴的扭转，这可以通过检查相应的 URDF 文件或检查与每个链接相关的齐次变换矩阵来找到（参见第 1.1 节）。您应该在报告和演示中清楚地解释如何确定扭转。

4.  创建您的碰撞避免场景，例如添加其他对象，从不同的初始和最终目标配置开始。通过重叠中间配置或使用动画来显示您的路径规划结果。您的场景的难度和新颖性将作为评估的考虑因素。不要初始化琐碎的路径，即无碰撞的初始化。

5.  在之前的任务之上，进一步为机器人机械臂末端执行器添加约束，使其 y 轴在从初始位置移动到目标位置（想象移动一杯咖啡的任务）期间保持直立。您还可以选择末端执行器的 x 或 z 轴，并将其与选定的世界框架轴对齐，只要您可以显示添加约束前后规划结果的差异。由于我们已经在代码中修复了初始和最终姿态，您可能需要调整末端执行器的初始和最终方向，以与您期望/选择的方向对齐，以方便规划。

### 备注

*   您确实需要了解所有代码才能调试和完成所有任务。
*   您可能需要修改给定的代码以适应您自己的代码，例如，采用您定义和使用的特定数据格式，根据您选择的机器人的最大伸及范围调整障碍物位置等。此外，如果您发现给定的代码不方便或效率低下，请随时修改/改进它。您还可以使用任何外部函数、库、代码片段等。
*   您所做的任何贡献或添加的任何功能（例如，更高效的计算、为更好的交互添加 GUI、修复现有代码中的错误、改进/扩展 STOMP 算法等）都将作为评分的考虑因素。请在演示期间以及报告中明确指出。

### 提交

*   请务必同时提交您的 PDF 报告和 MATLAB 代码。将所有文件包含在一个文件夹中，并将其压缩为一个 zip 文件。**每个小组只提交一个 zip 文件。**
*   **命名约定:** `Group(Number)_Report_Code`。
*   **提交截止日期:** 2025 年 11 月 13 日，下午 5:00。
*   对于每个任务，请创建一个包含所有必要代码的文件夹以重现您的结果。您可能希望根据 5 个任务来组织您的代码，即每个任务一个文件夹。您也可以提交一个代码库，但无论您提交什么，都应该让其他人可以轻松地为所有任务重现您的解决方案。您无需包含我们教科书《现代机器人学》（如任务 3 中所述）提供的代码，如果您没有修改其代码。包含一个 `readme.txt` 来指导您的代码的使用将是一个好习惯。
*   您可以在提交的所有任务中使用 PoE。
*   您的演示旨在解释您的工作以及您对我们的理解。您应该解释您做了什么，突出您取得了哪些特殊功能/有趣的结果等。

### 演示

*   演示将于 **11 月 13 日，星期四，晚上 6:00 至 9:00 在 E1-06-07** 进行。每个小组将有 10 分钟：7 分钟用于演示，3 分钟用于问答。
*   您可以选择播放预先录制的视频进行演示，然后进行问答环节（所有成员都应亲自出席）。
*   **每个成员都应该参与并展示您小组工作的一部分。** 您将按小组顺序进行演示，即从第 1 组到第 14 组（如果您需要重新安排，请联系助教）。您的小组只需在预定的演示时间前几分钟加入会议，并在演示后离开。
*   您可以使用自己的笔记本电脑或室内教学桌面进行演示。
*   整个演示过程将被录制（尽管我们将亲自会面）。

### 1.1 技术提示

*   给定的代码依赖于 **MATLAB Robotics System Toolbox**。确保在安装 MATLAB 时已选择它。
*   关于如何使用 `getTransform()` 函数的网页。请注意，在读取机器人的主体名称时，第 1 行比第 2 行快得多。
*   请注意，机器人主体/链接可能不总是从旋转关节开始。对于 UR 或某些其他机器人，主体/链接以无法旋转或移动的固定关节开始。确保您获得的移动关节的位置与您的关节角度规划正确对应。
*   对于某些机器人，URDF 文件将“base_link”的原点定义与基础框架不同。确保您始终如一地引用相同的固定/基础/空间框架。例如，
*   要查找机器人的几何参数，您可以加载机器人：
    然后检查齐次变换矩阵。例如，下面显示了 T01，即 KINOVA GEN3 的关节 1 到其父框架（关节 1）的配置：
*   或者，您可以参考机器人的 URDF 获取其几何信息。以下几行显示了 MATLAB 使用的 URDF 的检索位置（源 URDF 信息）：
    打开 URDF，您可以找到以下两个关节描述的片段。左侧代码片段是第一个关节，名为“Actuator1”。其几何数据与我们之前发现的信息一致：`rpy="3.1416 0 0"` 是关节 1 相对于其父链接（即 base_link）方向的欧拉角（滚转、俯仰、偏航）表示，也就是说，如果您围绕其 x 轴将 base_link 框架旋转 3.1416 弧度，那么您将获得关节 1 框架的方向。`xyz="0 0 0.15643"` 显示了关节 1 的原点相对于其父链接（base_link 框架的原点）的平移，也在 base_link 的框架中表示。请注意，轴 `xyz="0 0 1"` 表示该关节的旋转轴是其自身框架的 z 轴（**不是相对于基础框架**）。
    右侧代码片段是第二个关节，名为“Actuator2”。同样，原点中的数据是相对于其父链接（即“Shoulder_Link”）。类似地，轴 (0, 0, 1) 是相对于其**自身框架**，而不是基础/固定框架。
*   请注意，您只需要在整个程序中计算一次螺旋轴。因为它们仅取决于初始配置。更新关节坐标时，您只需将螺旋轴传递给相应的 PoE 公式，而无需重新计算所有螺旋轴。
*   您还可以通过使用 `getTransform()` 函数在初始配置下获得旋转轴和位置向量。然后按照我们在课堂上讨论的二维平面小车示例来计算螺旋轴，该示例仅使用叉积。但要确保您的角速度和线速度是正确的。
*   此外，您还可以使用 `getTransform()` 在某个**任意非零角度**下获取关节的配置/姿态。然后使用矩阵对数映射计算相应的扭转，然后对扭转进行归一化以获得螺旋轴，其方式与您在上次作业中完成的方式相同。
*   要为任务 5 中的末端执行器方向添加约束（即，保持 y 轴直立，您也可以选择保持其他轴直立），您可以：
    1.  选择一个任意方向（旋转矩阵），其 y 轴相对于世界坐标系是直立的，并向成本函数添加一个惩罚（即约束成本）。
    2.  或者，您可以仅惩罚末端执行器的 y 轴（其世界坐标，表示为 ŷst，您可以从正向运动学中获得）与世界坐标系的 z 轴（仅为 s = [0;0;1]）之间的差异。例如，惩罚可以是所谓的残差向量的 l1 范数：||ŷsb - 2s||1 := Σ|Ysb(i) – Îs(i)|，这只是残差向量中每个元素的绝对值之和。l1 范数可以使用 `norm(_, 1)` 函数计算，其中参数 1 表示 l1 范数。
*   多变量高斯采样函数 `mvnrnd` 需要 **Matlab Statistics and Machine Learning Toolbox**。确保在安装 Matlab 时选择它。
*   关节角度的初始化可能具有影响力，尤其是在存在不连续性/奇异点的情况下。您可能需要处理关节角度 θ ∈ [−π,π] 的不连续性以改善初始化，从而提高轨迹质量。您可能还想检查 MATLAB 中提供的球面线性插值函数 `slerp()`，但是它基于旋转的四元数表示。
